---
layout: post
title: Comment on Sharding in Ethereum
description: An alternate approach to sharding in Ethereum
---
Having read <a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQ">Vitalik Buterin's FAQ</a> on sharding in Ethereum, I propose a alternate approach, slicing the network horizontally instead of vertically. Instead of creating groups of nodes that are responsible for a subset of the state (shards), I propose to create groups of nodes that are responsible for the full state each. I.e. instead of having 50 shards with 100 nodes each, there would be 100 groups consisting of 50 subnodes each, with each group holding the full state. This won’t scale equally well as perfect sharding, but is much simpler to implement and more robust.

My background: as a former CTO of a distributed cloud storage startup, I have experienced many of the problems of executing transactions in distributed systems first hand. Thus, I think I have developed a gut feeling for what works well over the years. However, I am only tangentially familiar with how Ethereum is implemented and also did not read everything that was already said on the topic. So it is well possible that this proposal contains overlaps with previous ideas and maybe even some fundamental mistakes. If there is anything my past has taught me is that one should never be too confident about technical ideas before having actually implemented and tested them.

Subnodes: One of the great advantages of Ethereum in comparison to other cryptocurrencies is that the state is encoded in a Merklix tree. This allows to create compact proofs about the current state. In comparison, it is not possible to prove that a given output is unspent in Bitcoin without scanning the whole transaction history since the creation of that output. This valuable property of Ethereum allows the creation of subnodes: nodes that are only concerned with a subset of the state, and only download and validate transactions that are relevant to that subset. Whoever runs a subnode is free to specify what subset of the state he is interested in. By default, this can be a random subset, but it might also make sense for a specific users to track the state that is relevant to all the contracts he is involved in. This stands in contrast to Vitalik’s proposal, where nodes are exogenously assigned to a shard. By running such a node, a user would be able to monitor all the contracts relevant to him and even prove if something went wrong, i.e. if an invalid state transition was included in the block chain, he could provide the relevant transaction together with the Merkle-verified data before and after the transaction to prove to anyone that the transaction was incorrectly processed. That node could also craft cross-shard transactions that include all the relevant tree data with only O(log n) overhead, but executing those transactions reliably could still be a problem, in particular if they depend on dynamic data (a problem Vitalik also discusses).

Block creation: In order to reliably validate old blocks and forge new blocks of transactions, subnodes have an incentive to form trusted groups with other subnodes. Ideally, each group is large enough to cover the full state. Ideally, they also have some “mining power” among themselves, such that they can create new blocks. In the simplest case, such a group of nodes is actually just one supercomputer operated by a powerful miner and corresponds to today’s full nodes. But it also could be group of servers operated by the same miner. Or it could be a group of subnodes operated by people who trust each other. Or it could be a group of subnodes that found together similar to today’s mining pools. For groups of random nodes from the Internet, there obviously needs some mechanism to enforce correct behavior. The most simple one would be to expel subnodes that did not process a transaction correctly, which fortunately can easily be detected once a block created by that group gets declined by the others. Data availability is similarly hard to ensure as in other systems. How these groups are formed and organized exactly is not important at this stage. What is important is that there exists an incentive to behave well as a group and that there is a large number of such groups so they stand in competition with each other. Generally, having diversity in the way groups are formed (manually or automatically) makes the system as a whole more robust.

The advantage of this approach is that it provides a simple and robust path to scaling, while avoiding the synchronization headaches associated with cross-shard transactions. Agreeing on a “cross-shard” transaction within a trusted group of nodes is much easier than across large distributed shards. Also, this approach has the benefit of preserving one global state as opposed to the thought of maintaining separate states for each shard. Under the views discussed herein, the problem of scaling Ethereum is reduced to the problem of organizing a group of subnodes such that behave like one of today’s full node collectively.
